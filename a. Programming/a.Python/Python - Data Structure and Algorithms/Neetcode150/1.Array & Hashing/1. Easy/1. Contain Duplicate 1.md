This topic from NeetCode. There are 3 contain duplicate. I started Contain duplicate 0, 1, 2. How contain duplicate 1 would be?



"Contain Duplicate" is a common problem in coding interviews and competitive programming. It typically involves checking if there are any duplicate elements in a given array or list. The variations of this problem can introduce additional constraints or requirements.

For "Contain Duplicate 1," you might be referring to a variation of the basic "Contains Duplicate" problem. Here's a typical description of the basic version, followed by potential variations that could be considered as "Contain Duplicate 1":

### Basic Problem (Contain Duplicate 0)

**Problem Statement:**
Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.

**Example:**
```
Input: nums = [1,2,3,1]
Output: true
```

### Potential Variation for "Contain Duplicate 1"

One variation could involve additional constraints or slightly different requirements:

#### Problem Statement for Contain Duplicate 1

**Problem Statement:**
Given an integer array `nums` and an integer `k`, return `true` if there are two distinct indices `i` and `j` in the array such that `nums[i] == nums[j]` and the absolute difference between `i` and `j` is at most `k`.

**Example:**
```
Input: nums = [1,2,3,1], k = 3
Output: true
```

This version adds a constraint where duplicates must not only exist but also be within a certain index distance from each other.

### Approach

To solve this variation efficiently:

1. **Use a HashMap (or Dictionary):**
   - Traverse through the list while maintaining a hashmap to store each number and its latest index.
   - For each number, check if it already exists in the hashmap.
   - If it exists, check the difference between the current index and the stored index.
   - If this difference is less than or equal to `k`, return true.
   - Otherwise, update the hashmap with the current index for that number.

2. **Time Complexity:** O(n), where n is the length of the array because we make a single pass through it.

This approach ensures we efficiently check for duplicates within a specific range without needing nested loops.

pls show me python, step by step pls.



Certainly! Let's walk through the solution for the "Contain Duplicate 1" problem step by step in Python. We'll use a dictionary to keep track of elements and their indices as we iterate through the array.

### Step-by-Step Solution

#### Problem Restatement
We need to determine if there are two distinct indices `i` and `j` such that `nums[i] == nums[j]` and `|i - j| <= k`.

#### Example
- **Input:** `nums = [1, 2, 3, 1]`, `k = 3`
- **Output:** `True` (because the duplicate number `1` is within 3 indices)

### Implementation

Here's how you can implement this solution in Python:

```python
def contains_nearby_duplicate(nums, k):
    # Create a dictionary to store each number's latest index
    num_index_map = {}

    # Iterate over the list with both index and value
    for i, num in enumerate(nums):
        # Check if the current number already exists in the map
        if num in num_index_map:
            # Calculate the difference between current index and stored index
            difference = i - num_index_map[num]
            # If the difference is less than or equal to k, return True
            if difference <= k:
                return True
        
        # Update or add the current number's index in the map
        num_index_map[num] = i
    
    # If no such pair is found, return False
    return False

# Test case example
nums = [1, 2, 3, 1]
k = 3
print(contains_nearby_duplicate(nums, k))  # Output: True
```

### Explanation of Each Step

1. **Initialize a Dictionary:**
   - We use a dictionary called `num_index_map` to store each number as a key and its latest index as its value.

2. **Iterate Over the List:**
   - We use Python's built-in `enumerate()` function to get both index (`i`) and value (`num`) from `nums`.

3. **Check for Duplicates:**
   - For each element, we check if it already exists in our dictionary.
   - If it does exist, we calculate the difference between its current index (`i`) and its last recorded index from our dictionary.

4. **Check Index Difference:**
   - If this difference is less than or equal to `k`, we have found two duplicates within range; hence we return `True`.

5. **Update Dictionary:**
   - Whether or not a duplicate was found within range, we update our dictionary with the current element's latest index.

6. **Return Result:**
   - If no such pair is found by the end of iteration, we return `False`.

This algorithm efficiently checks for nearby duplicates with a time complexity of O(n), where n is the length of the array.