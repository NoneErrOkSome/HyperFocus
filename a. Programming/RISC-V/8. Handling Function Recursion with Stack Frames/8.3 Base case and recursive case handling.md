# **8.3 Base Case and Recursive Case Handling in RISC-V**

Recursion requires **two essential parts**:

1. **Base Case** â†’ The condition that **stops** recursion.
2. **Recursive Case** â†’ The step where the function calls itself to break the problem into smaller subproblems.

Without a **base case**, the function will **never stop calling itself**, leading to **stack overflow**.

---

## **1ï¸âƒ£ Understanding Base and Recursive Cases**

### **ğŸ“Œ Base Case (Stopping Condition)**

- **A condition where recursion stops** and returns a final result.
- Prevents **infinite recursion** and stack overflow.

### **ğŸ“Œ Recursive Case (Reduction Step)**

- **Breaks down the problem** into smaller subproblems.
- Calls itself with **a smaller input** each time.

ğŸ“Œ **Example: Factorial Function (`factorial(n)`)**

```c
int factorial(int n) {
    if (n == 1) return 1;      // Base Case
    return n * factorial(n-1); // Recursive Case
}
```

âœ” **Base Case:** `if (n == 1) return 1;`  
âœ” **Recursive Case:** `return n * factorial(n-1);`

---

## **2ï¸âƒ£ Implementing Base Case & Recursive Case in RISC-V**

Letâ€™s implement **factorial(n)** step by step in RISC-V.

ğŸ“Œ **Factorial in RISC-V Assembly**

```assembly
.global _start

_start:
    li a0, 5        # Compute factorial(5)
    jal factorial   # Call factorial function

    li a7, 93       # Exit syscall
    ecall

factorial:
    addi sp, sp, -12  # Allocate stack frame
    sw ra, 8(sp)      # Save return address
    sw a0, 4(sp)      # Save function argument (n)

    li t0, 1
    beq a0, t0, base_case  # Base Case: if n == 1, return 1

    addi a0, a0, -1  # Reduce n (Recursive Case)
    jal factorial    # Call factorial(n-1)

    lw t1, 4(sp)     # Load saved n
    mul a0, a0, t1   # Multiply result with n

base_case:
    lw ra, 8(sp)     # Restore return address
    addi sp, sp, 12  # Free stack space
    ret              # Return to caller
```

---

## **3ï¸âƒ£ Breakdown of Base Case and Recursive Case**

### **ğŸ“Œ Base Case: Stopping Recursion**

```assembly
li t0, 1
beq a0, t0, base_case  # If n == 1, jump to base_case
```

âœ” If `n == 1`, the function **returns immediately**, preventing further recursion.

### **ğŸ“Œ Recursive Case: Breaking Down the Problem**

```assembly
addi a0, a0, -1  # Reduce n
jal factorial    # Call factorial(n-1)
```

âœ” Calls `factorial(n-1)`, making the problem **smaller each time**.

### **ğŸ“Œ Returning & Stack Cleanup**

```assembly
lw t1, 4(sp)     # Load saved n
mul a0, a0, t1   # Multiply result with n

lw ra, 8(sp)     # Restore return address
addi sp, sp, 12  # Free stack space
ret              # Return to caller
```

âœ” **Unwinds recursion**, restoring values and computing the final result.

---

## **4ï¸âƒ£ Visualizing Recursive Calls in the Stack**

Let's see **how the stack changes** when computing `factorial(3)`.

|**Recursive Call**|**Value of `n`**|**Stack Frame**|
|---|---|---|
|`factorial(3)`|`n=3`|Saves `ra`, `n` â†’ Calls `factorial(2)`|
|`factorial(2)`|`n=2`|Saves `ra`, `n` â†’ Calls `factorial(1)`|
|`factorial(1)`|`n=1`|Base Case â†’ Returns `1`|
|Return to `factorial(2)`|Multiplies `2 * 1` â†’ Returns `2`||
|Return to `factorial(3)`|Multiplies `3 * 2` â†’ Returns `6`||

ğŸ“Œ **Key Takeaway:**

- **Each recursive call pushes a new stack frame.**
- **Base case stops recursion and starts returning values.**
- **Recursive case continues calling itself with smaller values.**

---

## **5ï¸âƒ£ What Happens Without a Base Case?**

If we **remove the base case**, recursion will **never stop**, leading to **stack overflow**.

ğŸ“Œ **Incorrect Example (Infinite Recursion)**

```assembly
factorial:
    addi a0, a0, -1
    jal factorial   # No base case, will never stop!
```

ğŸ”´ **What Happens?**

- The function keeps calling itself **forever**.
- The **stack keeps growing**, eventually crashing the program.

âœ” **Always ensure a base case is present!**

---

## **6ï¸âƒ£ Summary: Base Case vs. Recursive Case in RISC-V**

|**Concept**|**Key Idea**|
|---|---|
|**Base Case**|Stops recursion when a condition is met (`n == 1`).|
|**Recursive Case**|Calls itself with a smaller value (`n-1`).|
|**Stack Growth**|Each recursive call adds a new stack frame.|
|**Stack Cleanup**|When recursion stops, frames are removed, and results are returned.|
|**Avoiding Stack Overflow**|Always include a **base case** to prevent infinite recursion.|

ğŸ“Œ **Final Takeaways:**

- **Base cases are essential to prevent infinite recursion.**
- **Recursive cases reduce the problem size until the base case is met.**
- **Stack frame management ensures smooth execution and correct results.**

---

### **ğŸ“Œ Next: 8.1.1 How Recursive Calls Store Return Addresses in the Stack (Reinforcement)**

Would you like to **continue with reinforcement topics**, or do you have any questions before moving on? ğŸš€