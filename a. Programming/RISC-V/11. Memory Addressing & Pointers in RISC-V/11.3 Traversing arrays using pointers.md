# **11.3 Traversing Arrays Using Pointers in RISC-V**

### **ğŸ“Œ Why Use Pointers to Traverse Arrays?**

Instead of using **fixed indexes (`arr[i]`)**, pointers allow **efficient traversal of arrays** by: âœ” **Accessing elements directly in memory**  
âœ” **Reducing arithmetic operations**  
âœ” **Optimizing loops for speed**

---

## **1ï¸âƒ£ Accessing Array Elements with Pointers**

An array is stored as a **continuous block of memory**, where **each element is accessed using its address**.

ğŸ“Œ **C Equivalent (Using Pointers)**

```c
int arr[] = {5, 10, 15};
int *ptr = arr;  // Pointer to the first element
int value = *(ptr + 1);  // Access second element
```

ğŸ“Œ **RISC-V Assembly Equivalent**

```assembly
.section .data
arr: .word 5, 10, 15  # Define an array

.section .text
.global _start

_start:
    la a1, arr        # Load base address of array
    lw a0, 4(a1)      # Load second element (*ptr + 1)

    li a7, 93         # Exit syscall
    ecall
```

âœ… **How It Works:**

1. `la a1, arr` â†’ **Loads the base address of `arr`**.
2. `lw a0, 4(a1)` â†’ **Loads second element (`10`)** by offsetting `4` bytes (`4 * 1`).

ğŸ“Œ **Key Takeaway:**  
âœ” **Array elements are accessed by incrementing pointer offsets (`4 bytes per word`).**

---

## **2ï¸âƒ£ Traversing an Array Using a Loop**

ğŸ“Œ **C Equivalent**

```c
int arr[] = {5, 10, 15};
int *ptr = arr;
for (int i = 0; i < 3; i++) {
    printf("%d", *(ptr + i));  // Access each element
}
```

ğŸ“Œ **RISC-V Assembly**

```assembly
.section .data
arr: .word 5, 10, 15  # Define an array

.section .text
.global _start

_start:
    la a1, arr        # Load base address of array
    li t0, 3          # Loop counter (array size)
    li t1, 0          # Index i = 0

loop:
    bge t1, t0, end   # If i >= 3, exit loop
    lw a0, 0(a1)      # Load current element
    addi a1, a1, 4    # Move pointer to next element
    addi t1, t1, 1    # Increment index
    j loop            # Repeat loop

end:
    li a7, 93         # Exit syscall
    ecall
```

âœ… **How It Works:**

1. `la a1, arr` â†’ **Loads base address of `arr`**.
2. `lw a0, 0(a1)` â†’ **Loads current element from memory.**
3. `addi a1, a1, 4` â†’ **Moves to next element by increasing pointer.**
4. `bge t1, t0, end` â†’ **Checks if loop should exit.**

ğŸ“Œ **Key Takeaway:**  
âœ” **Pointer increments (`addi a1, a1, 4`) replace array indexing.**

---

## **3ï¸âƒ£ Modifying an Array Using Pointers**

ğŸ“Œ **C Equivalent**

```c
int arr[] = {1, 2, 3};
int *ptr = arr;
for (int i = 0; i < 3; i++) {
    *(ptr + i) *= 2;  // Double each element
}
```

ğŸ“Œ **RISC-V Assembly**

```assembly
.section .data
arr: .word 1, 2, 3  # Define an array

.section .text
.global _start

_start:
    la a1, arr        # Load base address of array
    li t0, 3          # Loop counter (array size)
    li t1, 0          # Index i = 0

loop:
    bge t1, t0, end   # If i >= 3, exit loop
    lw a0, 0(a1)      # Load current element
    slli a0, a0, 1    # Multiply by 2
    sw a0, 0(a1)      # Store modified value back in array
    addi a1, a1, 4    # Move pointer to next element
    addi t1, t1, 1    # Increment index
    j loop            # Repeat loop

end:
    li a7, 93         # Exit syscall
    ecall
```

âœ… **How It Works:**

1. `lw a0, 0(a1)` â†’ **Loads element from array**.
2. `slli a0, a0, 1` â†’ **Multiplies by 2 (`<< 1`).**
3. `sw a0, 0(a1)` â†’ **Stores updated value.**

ğŸ“Œ **Key Takeaway:**  
âœ” **Pointers allow in-place modification without explicit indexing.**

---

## **4ï¸âƒ£ Summary: Traversing Arrays Using Pointers in RISC-V**

|**Concept**|**Key Idea**|
|---|---|
|**Pointers access array elements**|Base address + offset (`lw a0, 4(a1)`)|
|**Looping over arrays with pointers**|Pointer increments (`addi a1, a1, 4`)|
|**Modifying arrays via pointers**|`sw a0, 0(a1)` updates memory|

ğŸ“Œ **Final Takeaways:**

- **Pointers enable efficient array traversal.**
- **Use pointer arithmetic (`base + offset`) instead of indexing.**
- **Loops can dynamically traverse and modify arrays.**

---

### **ğŸ“Œ Next: 11.1.1 Understanding Memory Layout in RISC-V (Reinforcement)**

Would you like to **continue with memory layout reinforcement**, or do you have any questions before moving forward? ğŸš€